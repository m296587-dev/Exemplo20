#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <time.h> // Para gerar números aleatórios na jogada não-estratégica

// --- Definições Globais e Variáveis ---
#define MAX_FIB_COUNT 50 // Suficiente para números até aproximadamente 1.2 x 10^10
#define MAX_N_VALUE 1000000000 // Limite para N para evitar overflow de int e facilitar visualização
#define MAX_ARBITRARY_MOVE_FACTOR 2 // Para a jogada arbitrária (quando o jogador não tem a estratégia vencedora)

int fibonacci_sequence[MAX_FIB_COUNT];
int fib_count = 0; // Quantidade real de números de Fibonacci gerados

// --- Funções Auxiliares de Fibonacci e Zeckendorf ---

// Gera a sequência de Fibonacci (F_n, onde F_1=1, F_2=1, F_3=2, ...)
// Para o Teorema de Zeckendorf, geralmente usamos F_n para n >= 2, ou seja, {1, 2, 3, 5, 8, ...}
void generate_fibonacci() {
    fibonacci_sequence[0] = 1; // F1
    fibonacci_sequence[1] = 1; // F2
    fib_count = 2;
    for (int i = 2; i < MAX_FIB_COUNT; i++) {
        long long next_fib = (long long)fibonacci_sequence[i-1] + fibonacci_sequence[i-2];
        if (next_fib > MAX_N_VALUE) { // Garante que não exceda o limite para N
            break;
        }
        fibonacci_sequence[i] = (int)next_fib;
        fib_count++;
    }
}

// Verifica se um número é um termo da sequência de Fibonacci
bool is_fibonacci(int n) {
    for (int i = 0; i < fib_count; i++) {
        if (fibonacci_sequence[i] == n) {
            return true;
        }
    }
    return false;
}

// Encontra o menor termo da expansão de Zeckendorf para 'num'
// (Zeckendorf Representation: N = F_k1 + F_k2 + ... + F_kr, where k_i >= k_i+1 + 2)
int get_zeckendorf_smallest_term(int num) {
    if (num <= 0) return 0;
    if (is_fibonacci(num)) return num; // Caso num seja um Fibonacci, ele é seu próprio "menor termo" (não aplicado na estratégia para não-Fibonacci)

    int remaining = num;
    int last_used_fib_index = -1; // Índice no array fibonacci_sequence
    int smallest_term_found = -1;

    // Itera da maior para a menor Fibonacci na sequência gerada
    for (int i = fib_count - 1; i >= 0; i--) {
        if (fibonacci_sequence[i] > remaining) {
            continue; // Este Fibonacci é muito grande
        }

        // Verifica a regra de não-consecutividade
        // fibonacci_sequence[i] corresponde a F_k. last_used_fib_index corresponde a F_j.
        // Se F_j foi usado, o próximo F_k não pode ser F_{j-1}.
        // Os índices aqui são no array `fibonacci_sequence`, não os índices 'k' da notação F_k.
        // fib_sequence[idx] e fib_sequence[idx-1] são consecutivos no array.
        // A regra de Zeckendorf diz que F_k e F_k-1 não podem ser usados juntos.
        // Se `fibonacci_sequence[last_used_fib_index]` foi usado, não podemos usar `fibonacci_sequence[last_used_fib_index-1]`.
        // Então, `i` não pode ser `last_used_fib_index - 1`.
        if (last_used_fib_index == -1 || i < last_used_fib_index - 1) { // Verifica se o índice atual 'i' não é imediatamente anterior ao 'last_used_fib_index'
            remaining -= fibonacci_sequence[i];
            smallest_term_found = fibonacci_sequence[i]; // A cada subtração, o termo subtraído é potencialmente o menor
            last_used_fib_index = i;

            if (remaining == 0) {
                return smallest_term_found; // Encontrou a menor parcela da soma de Zeckendorf
            }
        }
    }
    return smallest_term_found; // Deve retornar um valor válido se num > 0
}

// --- Lógica do Jogo ---

// Função para obter a jogada de um jogador
// is_winning_player: true se o jogador atual tem a estratégia vencedora (enfrentando um não-Fibonacci)
// current_pile: número atual de pedras na pilha
// last_k_opponent: quantidade de pedras que o oponente removeu na última jogada
int get_player_move(char *player_name, int current_pile, int last_k_opponent, bool is_winning_player) {
    int k_max;
    if (last_k_opponent == 0) { // Primeira jogada de Arnaldo
        k_max = current_pile - 1; // 1 <= k < N
    } else {
        k_max = 2 * last_k_opponent; // 1 <= k <= 2k_anterior
    }

    int move = -1;
    bool valid_move = false;

    if (is_winning_player) {
        // Estratégia vencedora: remover o menor termo da expansão de Zeckendorf
        // Esta estratégia só é aplicada quando o current_pile NÃO é um Fibonacci
        move = get_zeckendorf_smallest_term(current_pile);
        if (move < 1 || move > k_max || move >= current_pile) {
             printf("⚠️ %s (ESTRATÉGIA VENCEDORA, mas a jogada calculada não é válida para k_max=%d ou move>=current_pile=%d. Jogando aleatoriamente).\n", player_name, k_max, current_pile);
             // Se a estratégia calculada não for válida, joga de forma arbitrária
             do {
                move = (rand() % k_max) + 1; // Um valor entre 1 e k_max
             } while (move >= current_pile && current_pile > 1); // Garante que a pilha não zere prematuramente se não for a última jogada
             if (move >= current_pile && current_pile > 0) move = current_pile; // Se for a última pedra, pega
             if (move < 1 && current_pile > 0) move = 1; // Pelo menos 1 pedra
        } else {
             printf("✅ %s (ESTRATÉGIA VENCEDORA) remove %d pedras.\n", player_name, move);
        }
    } else {
        // Jogador não tem a estratégia vencedora (enfrentando um Fibonacci)
        // O jogador deve fazer uma jogada arbitrária válida.
        // Para simplificar, o computador fará uma jogada aleatória válida.
        // Para interação humana, descomente a parte do scanf.
        printf("�� %s (jogada arbitrária, Max: %d) é a sua vez. Quantas pedras você remove (1 a %d)? ", player_name, k_max, k_max > current_pile ? current_pile : k_max);
        
        // Simulação de jogada arbitrária: tira entre 1 e min(k_max, current_pile -1)
        int max_allowed_for_arbitrary = k_max;
        if (max_allowed_for_arbitrary >= current_pile && current_pile > 0) { // Se pode pegar tudo, tem que poder.
            max_allowed_for_arbitrary = current_pile;
        } else if (current_pile > 1 && max_allowed_for_arbitrary == current_pile) { // Não pode esvaziar a pilha se não for para ganhar
             max_allowed_for_arbitrary = current_pile -1;
        }


        // Garante que max_allowed_for_arbitrary seja pelo menos 1, a menos que current_pile seja 0.
        if (current_pile == 0) max_allowed_for_arbitrary = 0;
        else if (max_allowed_for_arbitrary < 1) max_allowed_for_arbitrary = 1;


        if (current_pile == 1) { // Última pedra, precisa pegar 1
            move = 1;
        } else {
            if (max_allowed_for_arbitrary == 0) max_allowed_for_arbitrary = 1; // Evitar divisão por zero ou rand com 0
            move = (rand() % max_allowed_for_arbitrary) + 1;
        }

        // Para permitir input do usuário:
        // scanf("%d", &move);
        // while (move < 1 || move > k_max || move > current_pile) {
        //     printf("Jogada inválida. Escolha entre 1 e %d (máximo %d pedras na pilha): ", k_max, current_pile);
        //     scanf("%d", &move);
        // }
        printf("%s remove %d pedras (arbitrariamente).\n", player_name, move);
    }
    return move;
}


int main() {
    srand(time(NULL)); // Inicializa o gerador de números aleatórios

    generate_fibonacci(); // Preenche a sequência de Fibonacci

    int N;
    printf("--- Jogo das Pedras (Estratégia de Fibonacci/Zeckendorf) ---\n");
    printf("Digite o número inicial de pedras na pilha (N > 2, Max: %d): ", MAX_N_VALUE);
    scanf("%d", &N);

    if (N <= 2 || N > MAX_N_VALUE) {
        printf("Número de pedras inválido. N deve ser maior que 2 e menor que %d.\n", MAX_N_VALUE);
        return 1;
    }

    int current_pile = N;
    int last_k_removed = 0; // K removido na jogada anterior (0 para a primeira jogada de Arnaldo)
    char *current_player_name;
    bool arnaldo_turn = true; // Arnaldo começa

    printf("\nInício do jogo com %d pedras.\n", N);

    // Determina quem tem a estratégia vencedora
    bool arnaldo_has_winning_strategy = !is_fibonacci(N);
    printf("Condição inicial: N=%d é %s Fibonacci.\n", N, is_fibonacci(N) ? "" : "NÃO");

    if (arnaldo_has_winning_strategy) {
        printf("Portanto, Arnaldo possui a estratégia vencedora.\n");
    } else {
        printf("Portanto, Bernaldo possui a estratégia vencedora.\n");
    }
    printf("----------------------------------------------------------\n");

    while (current_pile > 0) {
        if (arnaldo_turn) {
            current_player_name = "Arnaldo";
            printf("\n-- Vez de Arnaldo -- (Pilha: %d, Max remover: %d)\n", current_pile, last_k_removed == 0 ? N-1 : 2*last_k_removed);
            
            // Arnaldo tem a estratégia se N inicial NÃO era Fibonacci.
            // Ele só aplica a estratégia se a pilha atual NÃO for Fibonacci.
            int move_k = get_player_move(current_player_name, current_pile, last_k_removed, arnaldo_has_winning_strategy && !is_fibonacci(current_pile));
            
            current_pile -= move_k;
            last_k_removed = move_k;

            if (current_pile == 0) {
                printf("Arnaldo removeu as últimas %d pedras. Arnaldo VENCE!\n", move_k);
                break;
            }
        } else {
            current_player_name = "Bernaldo";
            printf("\n-- Vez de Bernaldo -- (Pilha: %d, Max remover: %d)\n", current_pile, 2*last_k_removed);
            
            // Bernaldo tem a estratégia se N inicial ERA Fibonacci.
            // Ele só aplica a estratégia se a pilha atual NÃO for Fibonacci.
            int move_k = get_player_move(current_player_name, current_pile, last_k_removed, !arnaldo_has_winning_strategy && !is_fibonacci(current_pile));
            
            current_pile -= move_k;
            last_k_removed = move_k;

            if (current_pile == 0) {
                printf("Bernaldo removeu as últimas %d pedras. Bernaldo VENCE!\n", move_k);
                break;
            }
        }

        printf("Pedras restantes na pilha: %d\n", current_pile);
        arnaldo_turn = !arnaldo_turn; // Alterna o turno
    }

    printf("\n--- Fim do Jogo ---\n");

    return 0;
}
